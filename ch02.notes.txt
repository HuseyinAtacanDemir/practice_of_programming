*************************************************
*************************************************
Chapter 2: Algorithms and Data Structures
*************************************************
*************************************************

    In the end, only familiarity with the tools and techniques of the field will provide the right solution for a particular problem, and only a certain amount of experience will provide consistently professional results.
          Raymond Fielding, The Technique of Special Effects Cinematography

-------------------------------------------------------------------------------------------

  The study of alg/dst is one of the foundations of CS, a rich field of elegant techniques and sophisticated mathematical analyses. It's more than fun/games: a good alg/dst might solve a prob in seconds instead of years.

  In specialized fields (graphics, dbs, parsing, numerical analysis, simulation) ability to solve problems quickly depends on state-of-the-art alg/dst. One must find out what is already known and implemented in their field (alg/dst wise), lest he waste time doing poorly what others have already done well.

  All programs depend on alg/dst, only a few depend on the invention of new ones. Even complex programs (compiler, web browser, etc) utilize existing alg/dst (arr, list, tree, hash tbl, etc). When a prog needs something more elaborate, it will likely be based on simpler ones. Thus, for the programmer, the task is to know what alg/dst are available/appropriate/good for the job at hand.

  There are only a handful of alggos that show up in almost every program: search, sort. Similarly almost all dst are derived from few basic ones.

    
*************************************************
2.1 Searching
*************************************************

    Nothing beats an array for storing static tabular data. Compile time initialization makes it cheap and easy to construct such arrays.

    Ex: program to detect over utilized words in bad prose :D :

    char *flab[] = {
        "actually",
        "just",
        "quite",
        "really",
        NULL
    };

    The search routine needs to know the elem count of the arr: one way is to pass arrLen as an arg; another is to place a NULL marker at the end:

    // lookup: sequential search for word in array
    int lookup(char *word, char *array[])
    {
        int i;
        for (i = 0; array[i] != NULL; i++)
            if (strcmp(word, array[i]) == 0)
                return i;
        return -1;
    } 

    In c/c++ a param that is an arr of strs can be declared as char *arr[] or char **arr. First one makes it clearer how the param will be used.

    This alg is called sequential search, it looks at each elem to find a match. When data is small, sequential search is fast enough. Linear search: run-time -- data size -> linear relationship.

    Excerpt from a program that parses HTML, arr with textual names for well over 100 characters:
      typedef struct Nameval Nameval;
      struct Nameval {
          char    *name;
          int     value;
      };

      Nameval htmlchars[] = {
          "AElig",    0x00c6,
          "Aacute",   0x00c1,
          "Acirc",    0x00c2,
          /..../
          "zeta",     oxo3b6,
      };

    For a larger arr, better to use binary search. For bin search, table must be sorted, and we must know the length. NELEMS macro from Ch01 can help

    BinSearch with this table might look like this:

    // lookup: binary search for name in table; 
    // returns: index if found,  -1 if not found
    int lookup(char *name, Nameval table[], int nTable)
    {
        int low, high, mid, cmp;
          
        low = 0;
        high = nTable - 1;

        while (low <= high) {
            mid = (low + high) / 2;
            cmp = strcmp(name, table[mid].name);
            
            if (cmp < 0)
                high = mid - 1;
            else if (cmp > 0)
                low = mid + 1;
            else                // found match
                return mid;
        }
        return -1;              // no match
    }

  Putting all this together, to search htmlchars we write:
      half = lookup("frac12", htmlchars, NELEMS(htmlchars));
  to find the arr index of the symbol/char "1/2".

  
*************************************************
2.2 Sorting
*************************************************

    Binary search only works if the elements are sorted. If repeated searches are going to be made, it will be profitable to sort once and then use binSearch. If the data set is known in advance, it can be sorted when the program is written and built using compile-time initialization. If not, it must be sorted when the program is run.
    One of the best all-round sorting algs is quicksort, which was invented in 1960 by C.A.R. Hoare. Quicksort is a fine example of how to avoid extra computation. It works by partitioning an arr into little and big elements:

      pick one elem of the array (the "pivot")
      partition the other elems in to 2 groups:
          "little ones" that are < than the pivot
          "big ones" that are >= to the pivot
      recursively sort each group.

    When this process is finished, the arr is in order. QS is fast because once an elem is know to be less than the pivot value, we don't have to compare it to any of the big ones; similarly, big ones are not compared to the little ones. This makes it much faster than the simple sorting methods such as insertion/bubble etc that compare each element directly to all others.
    The version of QS presented here is the simplest but not the quickest:

      // quicksort: sort v[0]..v[n-1] into increasing order
      void quicksort(int v[], int n)
      {
          int i, last;
          
          if (n <= 1)   // nothing to do
              return;

          swap(v, 0, rand() % n);         // move pivot elem to v[0]
          last = 0;
          for (i = 1; i < n; i++)
              if (v[i] < v[0])
                  swap(v, ++last, i);

          swap(v, 0, last);               // restore pivot
          quicksort(v, last);             // recursively sort smaller part
          quicksort(v+last+1, n-last-1);  // recursively sort bigger part
      }
      
    The swap operation, which interchanges two elements, appears three times in quicksort, so it is best made intoa  separate fn:
      
      // swap: interchange v[i] and v[j]
      void swap(int v[], int i, int j)
      {
          int temp;
          
          temp = v[i];  
          v[i] = v[j];
          v[j] = temp;
      }


      return immedietaly if nArr <= 1
      pick pivot at random
      swap pivot with 0th elem
      loop over complete arr starting from index 1
          compare arr[i] to pivot (arr[0])
          if smaller 
              increment last
              swap arr[i] with arr[last]

      swap pivot with last (arr[0] with arr[last])
      sort arr[0]..arr[last-1]
      sort arr[last + 1]...arr[nArr-1] 
         
      If the partitioning split is unequal too often, the time complexity can grow like n^2 instead of nlogn. This implementation uses a random element as the pivot to reduce the chance that unusual input data will cause too many uneven splits.
      If all the input values are the same, the run time is n^2.

      The behavior of some algs depends strongly on input data. Perverse or unlucky inputs may cause an otherwise well-behaved algo to run extremely slowly or use a lot of mem. In the case of QS although a simple implementation like this might sometimes run slowly, more sophisticated implementations can reduce the chance of pathological behavior to almost zero.

  
*************************************************
2.3 Libraries
*************************************************

    The std libs for C and C++ include sort fns that should be robust against adverse inputs, and tuned to run as fast as possible.
    
    Library routines are prepared to sort any data type, but in return we must adapt to their interface, which may be somewhat more complicated than what we showed above. In C, the library function is named qsort, and we need to provide a comparison function to be called by qsort whenever it needs to compare two values. Since the values might be of any type, the comparison fn is handed two void* ptrs to the data items to be compared. The fn casts the ptrs to the proper type, extracts the data values, compares them, and returns the result (<0 0 >0, according to whether the first value is less than, equal to, or greater than the second).

    Here is an implementation for sorting an array of strings, which is a common case. We define a fn scmp to cast the arguments and call strcmp to do the comparison:
  
        // scmp: string compare of *p1 and *p2
        int scmp(const void *p1, const void *p2)
        {
            char *v1, *v2;
            
            v1 = *(char **) p1;
            v2 = *(char **) p2;
            return strcmp(v1, v2);
        }

    We cannot use strcmp directly as the comparison fn because qsort passes the address of each entry in the arr, &arr[i] (of type char **) and not arr[i] (of type char *).

    To sort elements arr[0] through arr[N-1] of an array of strings, qsort must be called with the array, its length, the size of items being sorted, and the comparison fn:

          char *arr[N];

          qsort(arr, N, sizeof(arr[0]), scmp);

    Here is a similar fn icmp for comparing integers:

          // icmp: integer compare of *p1 and *p2
          int icmp(const void *p1, const void *p2)
          {
              int v1, v2;
              v1 = *(int *) p1;
              v2 = *(int *) p2;
              
              if (v1 < v2)
                  return -1;
              else if (v1 == v2)
                  return 0;
              else
                  return 1;
          }

    We could have written
          return v1-v2;
but if v2 is large and positive and v1 is large and negative or vice versa, the resulting overflow would produce an incorrect answer. Direct comparison is longer but safe. 
  
    Again, the call to qsort requires the array, its length, the isze of hte items being sorted, and the comparison function:

          int arr[N];
          qsort(arr, N, sizeof(arr[0]), icmp);

    Ansi C also defines a binary search routine, bsearch. Like qsort, bsearch requires a ptr to a comparison fn (often the same one used for qsort); it returns a ptr to the matching element or NULL if not found. Here is our HTML lookup routine, rewritten to use bsearch:

          // lookup: use bsearch to find name in tab, return index
          int lookup(char *name, Nameval tab[], int ntab)
          {
              Nameval key, *np;

              key.name = name;
              key.value = 0;
              np = (Nameval *) bsearch(&key, tab, ntab, sizeof(tab[0]), nvcmp);

              if (np == NULL)
                  return -1;
              else
                  return np-tab;
          }

    As with qsort, the comparison routine receives the address of the tiems to be compared, so the key must have that type; in this example, we need to construct a fake Nameval entry that is passed to the comparison routine. The comparison routine itself is a fn nvcmp that compares two Nameval items by calling strcmp on their strinc components, ignoring their values:

          // nvcmp: compare two Nameval names
          int nvcmp(const void *va, const void *vb)
          {
              const Nameval a, b;

              a = (Nameval *) va;
              b = (Nameval *) vb;

              return strcmp(a->name, b->name);
          }

   This is analogous to scmp but differs because the strings are stored as members of a structure.

    The clumsiness of providing the key means that bsearch provides less leverage than qsort. A good general purpose sort routine takes a page of two of code, while binary search is not much longer than the code it takes to interface to bsearch. Nevertheless it is a good idea to use bsearch instead of implementing it yourself. Over the eyars, binary search has proven surprisingly hard for programmers to get right.

  Ex 2-1 Quicksort is most naturally expressed recursively. Write it iteratively and comapre the two versions. (Hoare describes how hard it was to wrok out quick sort iteratively, and how neatly it fell into place when he did it recursively.)

          void swap(int v[], int i, int j)
          {
              int temp = v[i];
              v[i] = v[j];
              v[j] = temp;
          }

          // qsort: Iterative qsort using a stack to simulate
          // what the call stack does during recursion
          void qsort(int v[], int n)
          {
              int i, start, end, last, top, stack[n];

              if (n <= 1)
                  return;

              start = 0;
              end   = n-1;

              top = -1;
              stack[++top] = start;
              stack[++top] = end;

              while (top > 0) {
                  end   = stack[top--];
                  start = stack[top--];
                  last  = start;

                  // pick a pivot and place it at the start idx
                  swap(v, start, start + (rand() % (end - start + 1)));        

                  for (i = start+1; i < end+1; i++)
                      if (v[i] < v[start])
                          swap(v, i, ++last);

                  // restore pivot to partition idx
                  swap(v, start, last);

                  if ((last-1) - start >= 1) {
                      stack[++top] = start;
                      stack[++top] = last - 1;
                  }

                  if (end - (last+1) >= 1) {
                      stack[++top] = last + 1;
                      stack[++top] = end;
                  }
              }
          }
