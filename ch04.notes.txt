*********************************************
*********************************************
Chapter 04: Interfaces
*********************************************
*********************************************

  "Before I built a wall I'd ask to know        \
  What I was walling in or walling out,         \
  And to whom I was like to give offence.       \
  Something there is that doesn't love a wall,  \
  That wants it down."
                    Robert Frost, Mending Wall

  The essence of design sis to balance competing goals and constraints. Although there may be many tradeoffs, when one is writing a small self-contained system, the ramifications of particular choices remain within the system and affect only the individual programmer. But when code is to be used by others, decisions have far wider repercussins.

  Among the issues to be worked out in a design are:

  • Interfaces: what services and access are provided? The interface is in effect a contract between supplier and customer. The desire to provide services that are uniform and convenient, with enough functionality to be easy to use but not so much as to become unwieldy

  • Information hiding: what information is visible and what is private? An interface must provide straightforward access to the components while hiding details of the implementation so they can be changed without affecting users.

  • Resource Management: who is responsible for managing memory and other limited resources? Here, the main problems are allocating and freeing storage, and managing shared copies of information.

  • Error handling: who detects errors, who reports them, and how? When an error is detected, what recovery is attempted?

  In Chapter 2 we looked at the individual pieces --the data structures-- from which a system is built. In Chapter 3, we looked at how to combine those into a small program. The topic now turns to the interfaces between components that might come from different sources. In this chapter we illustrate interface design by building a library of functions and data structurs for a common task. Along the way, we will present some principles of design. typically there are an enormous number of decisions to be made, but most are made almost unconsciously. Without these principles, the result is often the sort of haphazard interfaces that frustrate and impede programmers every day.


*********************************************
4.1 COMMA SEPARATED VALUES
*********************************************

    Comma separated values, or CSV, is the term for a natural and widely used representation for tabular data. Each row of a table is a line of text; the fields on each line are sepparated by commas. The table at the end of the previous chapter might begin this way in CSV format:

        ,"250MHz","400MHz","Lines of" 
        ,"R10000","Pentium II","source code"
        C,0.36 sec,0.30 sec,150 
        Java,4.9,9.2,105
    
    This format is read and written by programs such as spreadsheets; not coincidentally, it also appears on web pages for services such as stock price quotations. A popular web page for stock quotes presents a display like this:
        ------------------------------------------------------------------
        | Symbol  |      Last Trade     |      Change       |   Volume   |
        ------------------------------------------------------------------
        | LU      |  2:19PM  |  86-1/4  | +4-1/16 | +4.94%  |  5,804,800 |    
        ------------------------------------------------------------------
        | T       |  2:19PM  | 60-11/16 | -1-3/16 | -1.92%  |  2,468,000 |    
        ------------------------------------------------------------------
        | MSFT    |  2:24PM  | 106-9/16 |  +1-3/8 | +1.31%  | 11,474,900 |
        ------------------------------------------------------------------

                          Download Spreadsheet Format
                          ---------------------------

    Retrieving numbers by interacting with a web browser is effective but time consuming. It's a nuissance to invoke a web browser, wait, watch a barrage of ads, type a list of stocks, wait, wait, wait, then watch another barrage, all to get a few numbers. To process the numbers further requires even more interaction; selecting the "Download Spreadsheet Format" link retrieves a file that contains much the same information in lines of CSV data like these :

        "LU",86.25,"11/4/1998","2:19PM",+4.0625, 83.9375,86.875,83.625,5804800
        "T",60.6875,"11/4/1998","2:19PM",-1.1875, 62.375,62.625,60.4375,2468000
        "MSFT",106.5625,"11/4/1998","2:24PM",+1.375, 105.8125,107.3125,105.5625,11474900

    Conspicuous by its abscence in this process is the principle of letting the machine do the work. Browsers let your computer access data on a remote server, but it would be more convenient to retrieve the data without forced interaction. Underneath all the button pushing is a purely textual procedure --the browser reads some html, you type some text, the browser sends that to a server and reads some HTML back. With the right tools and language, it is easy to retrieve the info automatically. Here's a program in the language Tcl to access the stock quote web site and retrieve CSV data in the format above, preceded by a few header lines:

        # getquotes.tcl: stock prices for Lucent, AT&T, Microsoft
        set so [socket quote.yahoo.com 80]  ;#connect to server
        set q "/d/quites.csv?s=LU+T+MSFT&f=sl1d1t1ohgv"

        puts $so "GET $q HTTP/1.0\r\n\r\n"  ;# send requrest
        flush $so 
        puts [read $so]                     ;# read & print reply

    The cryptic sequence f=... that follows the ticker symbols in an undocumented control string, analogous to the first argument of printf, that determines what values to retrieve. By experiment, we determined that s identifies the stock symbol, l1 the last price, c1 the change since yesterday, and so on. What's important is not the details, which are subject to change anyway, but the possibility of automation: retrieving the desired information and converting it into the form we need without any human intervention. We can let the machine do the work.

    It typically takes a fraction of a second to run getquotes, far less interacting with a browser. ONce we have the data, we will want to process it further. Data formats like CSV work best if there are convenient libraries for converting to and from the format, perhaps allied with some auxiliary processing such as numerical conversions. But we do not know of an existing public library to handle CSV, so we will write one ourselves.

    In the next few sections, we will build three versions of a library to read CSV data and converti it into an internal representation. Along the way, we'll talk about issues that arise when designing software that must work with other software. For example, there does not appear to be a standard definition of CSV, so the implementation cannot be based on a precise specification, a common situation in the design of interfaces.


*********************************************
4.2 A PROTOTYPE LIBRARY 
*********************************************

    We are unlikely to get the design of a library or interface right on the first attempt. As Fred Brooks once wrote, "plan to throw away; you will, anyhow." Brooks was writing about large systems but the idea is relevant for any substantial piece of software. It is not usually until you have built and used a version of the program that you understand the issues well enough to get the design right.

    In this spirit, we will approach the construction of a library for CSV by building one to throw away, a prototype. Our first version will ignore many of the difficulties of a thoroughly engineered library, but will be complete anough to be useful and to let us gain some familiarity with the problem.

    Our starting point is a function csvgetline that reads one line of CSV data from a file into a buffer, splits it into fields in an array, removes the quotes, and returns the number of fields, Over the years, we have written similar code in almost every language we know, so it is a familiar task. Here is a prototype version in C; we have marked it as questionable because it is just a prototype:

?       char buf[200];        // input line buffer
?       char *fled[20];       // fields
?
?       // csvgetline: read and parse line, return field count
?       // sample input: "LU",82.25,"11/4/1998","2:19PM",+4.0625
?       int csvgetline(FILE *fin)
?       {
?           int nfield;
?           char *p, *q;
?
?           if (fgets(buf, sizeof(buf), fin) == NULL)
?               return -1;
?           nfield = 0;
?           for (q = buf; (p=strtok(q, ",\n\r")) != NULL; q = NULL)
?               field[nfield++] = unquote(p);
?           return nfield;
?       }

    The comment at the top of the function includes an example of the input format that the program accepts; such comments are helpful for programs that parse messy input.

    The CSV format is too complicated to be parsed easily by scanf so we use the C standard library function strtok. Each call of strtok(p, s) returns a pointer to the first token within p consisting of characters not in s; strtok terminates the token by overwriting the following character of the original string with a null byte. On the first call, strtok's first argument is the string to scan; subsequent calls use NULL to indicate that scanning should resume where it left off in the previous call. This is a poor interface. Because strtok stores a variable in a secret place between calls, only one sequence of calls may be active at one time; unrelated interleaved calls will interfere with each other.

    Our fn unquote removes the leading and trailing quotes that appear in the sample input above. It does not handle nested quotes, however, so although sufficient for a prototype, it is not general.

?       // unquote: remove leading and trailing quote
?       char *unquote(char *p)
?       {
?           if (p[0] == '"') {
?               if (p[strlen(p) - 1] == '"')
?                   p[strlen(p)-1] = '\0';
?               p++;
?           }
?           return p;
?       }

    A simple test program helps verify that csvgetline works:

?       // csvtest main: test csvgetline function
?       int main(void)
?       {
?           int i, nf;
?
?           while ((nf = csvgetline(stdin)) != -1)
?               for (i = 0; i < nf; i++)
?                   printf("field[%d] = '%s'\n", i, field[i]);
?           return 0;
?       }

    The printf encloses the fields in matching single quotes, which demarcate them and help revelat bugs that handle white space incorrectly.
  
    We can now run this on the output produced by getquotes.tcl

        sh> tclsh getquotes.tcl | csvtest

    Now we have a prototype that seems to work on data of the sort we showed above. But it might be prudent to try it on something else as well, especially if we plan to let others use it. We found another website that downloads stock quotes and obtained a file of similar information but in a different form: carriage return (\r) rather than newlines to separate records, and no terminating carriage return at the end of the file.

    With that kind of input, our prototype failed miserably.

    We designed our prototype after examining one data source, and we tested it orogonally only on data from that same source. Thus we shouldn't be surprised when the first encounter with a different source reveals gross failings. Long input lines, many fields, and unexpected or missing separators all cause trouble. This fragile prototype might serve for personal use or to demonstraate the feasibility of an approach, but no more than that. It's time to rethink the design before we try another implementation.

    We made large number of decisions, both implicit and explicit, in the prototype. Here are some of the choices that were made, not always in the best way for a general-purpose library. Each raises an issue that needs more careful attention.
  
  • The prototype doesn't handle long input lines or lots of fields. It can give wrong answers or crash because it doesn't even check for overflows, let alone return sensible values in case of errors.
  
  • The input is assumed to consist of lines terminated by newlines.
 
  • Fields are separated by commas and surrounding quotes are removed. There is no provision for embedded quotes or commas.

  • The input line is not preserved; it is overwritten by the process of creating fields.

  • No data is saved from one input line to the next; if something is to be remembered, a copy must be made.

  • Access to fields is through a global variable, the field array, which is shared by csvgetline and functions that call it; there is no control over access to the field contents or the pointers. There is also no attempt to prevent access beyond the last field.

  • The global variables make the design unsuitable for multi-threaded environments or even two sequences of interleaved calls.

  • The caller must open and close files explicitly; csvgetline reads only from open files.

  • Input and splitting are inextricably linked: each call reads a line and splits it into fields, regardless of whether the application needs that service.

  • The return value is the number of fields on the line; each line must be split to compute this value. There is also no way to distinguish errors from end of file.

  • There is no way to change any of these properties without changing the code.

    This long yet incomplete list illustrates some of the possible design tradeoffs. Each decision is woven through the code. That is fine for a quick job, lije parsing one fixed format from a known source. But what id the format changes, or a comma appears within a quoted string, or the server produces a long line or a lot of fields?

    It may seem easy to cope, since the "library" is small and only a prototype anyway. Imagine, however, that after sitting on the shelf for a few months or years the code becomes part of a larger program whose specification changes over time. How will csvgetline adapt? If that program is used by others, the quick choices made in the original design may spell trouble that surfaces years later. This scenario is representative of the history of many bad interfaces. It is a sad fact that a lot of quick and dirty code ends up un widely-used software, where it remains dirty and often not as quick as it should have been anyway.



*********************************************
4.3 A LIBRARY FOR OTHERS 
*********************************************

  Using what we learned from the prototype, we now want to build a library worthy of general use. The mos obvious requirement is that we must make csvgetline mor robust so it will handle long lines or many fields; it must also be more careful in the parsing of fields.

    To create an interface that others can use, we must consider the issues listed at the beginning of this chapter: interfaces, information hiding, resource management, and error handling. The interplay among these strongly affects the design. Our separation of these issues is a bit arbitrary, since they are interrelated.

INTERFACE: We decided on three basic opeartions:
        char  *csvgetline (FILE *)  : read a new CSV line
        char  *csvfield   (int n)   : return the n-th field of the current line
        int   csvnfield   (void)    : return the number of fields in the curent line

  What function value should csvgetline return? It is desiarble to return as much useful information as convenient, which suggests returning the number of fields, as in the prototype. But then the number of fields must be computed even if the fields are not being used. Another possible value is the input line length, which is affected by whether the trailing newline is preserved. After several experiments, we decided that csvgetline will return a pointer to the original line of input, or NULL if end of file has been reached.

  We will remove the newline at the end of the line returned by csvgetline, since it can easily be restored if necessary.

  The definition of a field is complicated; we have tried to match what we observe empirically in spreadsheets and other programs. A field is a sequence of zero or more characters. Fields are separated by commas. Leading and trailing blanks are preserved. A field may be enclosed in double-quote characters, in which case it may contain commas. A quoted field may contain double quote characters, which are represented by a double double quote; the CSV field "x""y" defines the string x"y. Fields my be empty; a fields specified as "" is empty, and identical to one specified by adjacent commas.

  Fields are numbered from zero. What if user asks for a non existent field by calling csvfield(-1) or csvfield(1000000)? We could return "" (empty string) because this can be printed and compared; programs that process variable numbers of fields would not have to take special precautions to deal with non existent ones. But that choice provides no way to distinguish empty from non existent. A second choice would be to print an error message or even abort; we will discuss shortly why this is not desirable. We decided to return NULL, the convenient value for a non existent string in C.


INFORMATION HIDING:

    The library will impose no limits on input line lenght or number of fields. To achieve this, either the caller must provide the memory or callee (the library) must allocate it. The caller of the library function fgets passes in an array and a maximum size. If line is longer than the buffer, it is broken into pieces. This behavior is unsatisfactory for the CSV interface, so our library will allocate memory as it discovers that more is needed.

    Thus only csvgetline knows about memory management; nothing about the way that it organizes memory is accessible from outside. The best way to provide that isolation is thrugh a function interface: csvgetline reads the next line, no matter how big, csvgfield(n) returns a pointer to thebytes of the n-th field of the current line, and csvnfield returns the number of fields on the current line.

    We will have to grow memory as longer lines or more fields arrive. Details of how that is done are hidden in the csv functions; no other part of the program knows how this works, for instance whether the library uses small arrays that grow, or very large arrays, or something completetly different. nor does the interface reveal when memory is freed.

    If user calls only csvgetline, there is no need to split into fields; lines can be split on demand. Whether field splitting is eager (done right away when the line is read) or lazy (done only when a field or count is needed) or very lazy (only the requested field is split) is another implementation detail hidden from the user.


RESOURCE MANAGEMENT:

    We must decide who is responsible for shared information. Does csvgetline return the original data or make a copy? We decided that the return value of csvgetline is a ptr to the org input, which will be overwritten when the next line is read. Fields will be built in a copy of the input line, and csvfield will return a ptr to the field within the copy. With this arrangement, the suer must make another copy if a particular line or field is to be saved or changed, and it is the users responsibility to release that storage when it is no longer needed. 

    Who opens and closes the input file? Whoever ppens an input file should do the corresponding close; matching tasts should be done at the same level or place. WE will assume that csvgetline is called with a FILE pounter to an already open file that the caller will close when processing is complete.

    Managing the resources shared or passed across the boundary between a library and its callers is a diffigult task, and there are often sound but cinflcting reasons to prefere various design choices. Errors and misunderstandings about the shared responsibilities are a frequent source of bugs. 

ERROR HANDLING

    Because csvgetline returns NULL, ther eis no good way to distinguish end of file from an error like running out of mem; similaryl, access to a non existent field causes no error. By analogy with ferror, we could add another fnction csvgeterror to the interface to report the most recent error, but for simplicity we will leave it out of this version.

    As a principle, library routines shoud not just die when an error occurs; error status wdhould be returned to the caller for approproate acion. Nor should they print messages or pop up dialog boxes, since they may be running in an env where a messag would interfere with something else. Error handling is a topic worth a sparate discussion of its own, later in this chapter.

SPECIFICATION

    The choices made above should be collected in one place as a specification of the serviecs that csvgetline provides and how it is to be used, In a large project, the specification prcedes the implementation, because psecifiers and implementers are usually different people and may be in different organizations. In practice, however, work often proceeds in parallel, with specification an docde evolving together, although sometimes the "specification" is written only after the fact to describe approx what the code does.

    The best approach is to write the specification early and revise it as we learn from the ongoing pimlementation. The more accurate and careful a specifiation is, the more likely that the resulting program will work well. Even for personal progras, it is valuable to prepare a reasonably thorough specification because it encourages consideration of alternatives and records the choices made. 

    For our purposes, the specification would include fn prototypes and a detailed prescription of beheavior, responsibilities and assumptions:



        Fields are separarted by commas.
        A field may be enclosed in db quote chars "..."
        A quoted field may contain commas but not newlines
        A quoted field may containe db quote chars ", represented by ""
        Fields may be empty; "" and an empty string both represents an empty field.
        Leading and trailing white space is preserved

        char *csvgetline(FILE *f);
            reads one line from open input file f;
                assumes taht input lines are terminated by \r, \n, \r\n, or EOF
            returns ptr to line, with terminator removed, or NULL if EOF occurred.
            line may be of arbitrary len; returns NULL of mem limit exceeded.
            line must be treated as read only storage;
                caller must make a copy to preserve or change contents

        char *csvfield(int n);
            fields are numbered from 0
            returns n-th field from the last line read by csvgetline
                returns NULL if n<0 or beyond last field
            fields are separated by commas
            fields may be surrounded by "..." such quotes are removed
                within ".." "" replaced by " and comma is not a separator
            in unquoted fields, quotes are regular chars
            there can be an arbitrary num of fields of any len
                returns NULL if mem lim exceeded
            field must be treated as read-only storage
                caller must make a copy to preserve or change contents
            behavior undefined if called before csvgetline is called

        int csvnfield(void);
            returns number of fields on last line read by csvgetline
            behavior undefined if called before csvgetline is called



    This spec still elaves open questions. For examlpe, what values should be returned by csvfield and csvnfield if they are called after csvgetline has encountered EOF? How should ill formed fields be handled? Nailing down all such puzzles is difficult even for a tiny system, and very challendging for a large one, though it is important to try. One often doesnt discover oversights and omissions until implementation is underway.

    The rest of this section contains a new implmentation of csvgetline that matches the spec. The lib is broken into two files, a header csv.h that containes the fn declarations that represent the public part of the interface, and an impleentation file csv.c that contains the code. Users include csv.h in their source code and link their completed code with the compiled version of csv.c; the source need never be visible.

    Here is the header file:

        // csv.h: interface for csv library
        extern char *csvgetline(FILE *f);   // read next input line
        extern char *csvfield(int n);       // return field n
        extern int  csvnfield(void);        // return number of fields

    The internal variables that store text and the internal fns like split are declared static so they are visible only within the file that containes them. This is the simples way to hide information in a C program.



        enum { NOMEM = -2 };          // out of mem signal

        static char *line   = NULL;   // input chars
        static char *sline  = NULL;   // line copy used by split
        static int maxline  = 0;      // size of line[]and sline[]
        static char **field = NULL;   // field ptrs
        static int maxfield = 0;      // size of field[]
        static int nfield   = 0;      // number of fields in field[]

        static char fieldsep[] = ","; // field separator chars



    The vars are initialized statically as well. These initial values are used to test whether to create or grow arrays.

    These declarations describe a simple data structure. The line array holds the input line; the sline array is created by copying chars from line and terminating each field. The field array points to entries in sline. This diagram shows the state of these three arrays after the input line ab, "cd", "e""f",,"g,h" has been processed. Underlined elements in sline are not part of any field:


            ----------------------------------------------------------------
    line    | a| b| ,| "| c| d| "| ,| "| e| "| "| f| "| ,| ,| "| g| ,| h| "|   

            ----------------------------------------------------------------
    sline   | a| b|\0| "| c| d|\0|\0| "| e| "| f|\0| "|\0|\0| "| g| ,| h|\0|
              ^       --  ^       -----  ^          -----  ^ --- ^
              0           1              2                 3     4


    Here is the fn csvgetline itself:

        // csvgetline: get one line, grow as needed
        // sample input: "LU",86.25,"11/4/1998","2:19PM",+4.0625
        char *csvgetline(FILE *fin)
        {
            int i, c;
            char *newl, *news;

            if (line == NULL) {           // allocate on first call
                maxline = maxfield = 1;
                line = (char *) malloc(maxline);
                sline = (char *) malloc(maxline);
                field = (char **) malloc(maxfield*sizeof(field[0]));
                if (line == NULL || sline == NULL || field == NULL) {
                    reset();
                    return NULL;
                }
            }
            for (i=0; (c=getc(fin))!=EOF && !endofline(fin,c); i++) {
                if (i >= maxline-1) {     // grow line
                    maxline *= 2;         // double current size
                    newl = (char *) realloc(line, maxline);
                    news = (char *) realloc(sline, maxline);
                    if (newl == NULL || news == NULL) {
                        reset();
                        return NULL;
                    }
                    line = newl;
                    sline = news;
                }
                line[i] = c;
            }
            line[i] = '\0';
            if (split() == NOMEM) {
                reset();
                return NULL;
            }
            return (c == EOF && i == 0) ? NULL : line;
        }

    An incoming line is accumulated in line, which is grown as necessary by a call to realloc; the size is doubled on each growth, as in Section 2.6. The sline array is kept the same size as line; csvgetline calls split to create the field pointers in a separate array called field, which is also grown as needed.

    As is our custom, we start the arrays very small and grow them on demand, to guarantee that the array growing code is exercised. If allocation fails, we call reset to restore the globals to their starting state, so a subsequent call to csvgetline has a chance of suceeding:

        // reset: set variables back to starting values
        static void reset(void)
        {
            free(line);
            free(sline);
            free(field);
            line = NULL;
            sline = NULL;
            field = NULL;
            maxline = maxfield = nfield = 0;
        }

    The endofline function handles the problem that an input line may be terminated by a carraige return, a newline, both, or even EOF:

        // endofline: check for and consume \r, \n, \r\n, or EOF
        static int endofline(FILE *fin, int c)
        {
            int eol;

            eol = (c=='\r' || c=='\n');
            if (c == '\r') {
                c = getc(fin);
                if (c != '\n' && c != EOF)
                    ungetc(c, fin); // read too far, put c back
            }
            return eol;
        }

    A separate function is necessary, since the stdin functions do not hand the rich variety of perverse formats encountered in real inputs.

    Our prototype used strtok to find the next token by searching for a separator character, normally a comma, but this made it impossible to handle quoted commas. A major change in the implementation of split is necessary, though its interface need not change. Consider these input lines:

        "",,""
        ,"",
        ,,

    Each line has three empty fields. Making sure that split parses them and other odd inputs correctly complicates it significantly, an example of how special cases and boundary conditions can come to dominate a program.

        // split: split line into fields
        static int split(void)
        {
            char *p, **newf;
            char **sepp;      // ptr to temp separator char
            int sepc;         // temp spearator char

            nfield = 0;
            if (line[0] == '\0')
                return 0;
            strcpy(sline, line);
            p = sline;

            do {
                if (nfield >= maxfield) {
                    maxfield *= 2;          // double current size
                    newf = (char **) realloc(field,
                                maxfield * sizeof(field[0]));
                    if (newf == NULL)
                        return NOMEM;
                    field = newf;
                }
                if (*p == '"')
                    sepp = advquoted(++p);    // skip initial quote
                else
                    sepp = p + strcspn(p, fieldsep);
                sepc = sepp[0];
                sepp[0] = '\0';               // terminate field
                field[nfield++] = p;
                p = sepp + 1;
            } while (sepc == ',');
            
            return nfield;
        }

    The loop grows the array of field ptrs if necessary, then calls one of two otehr fns to locate and process the enxt field. If the field begins with a quote, advquoted finds the field and returns a ptr to the separator that ends the field. Otherwise, to find the next comma we use the library fn strcspn(p, s), which searches a string p for the enxt occurrence of any char in string s; it returns the number of chars skipped over.

    Quotes within a field are represented by two adjacent quotes, so advquoted squeezes those into a single one; it also removes the quotes that surround the field. Some complexity is added by an attempt to cope with plausible inputs that dont match the spec, such as "abc"def. In such cases, we append whatever follows the second quote until the next separator as part of this field. Microsoft Excel appears to use a similar alg.

        // advquoted: quoted field; return ptr to next separator
        static char *advquoted(char *p)
        {
            int i, j;

            for (i = j = 0; p[j] != '\0'; i++, j++) {
                if (p[j] == '"' && p[++j] != '"') {
                    // copy up to next separator or \0
                    int k = strcspn(p+j, fieldsep);
                    memmove(p+i, p+j, k);
                    i += k;
                    j += k;
                    break; 
                }
                p[i] = p[j];
            }
            p[i] = '\0';
            return p + j;
        }

    Since the input line is already split, csvfield and csvnfield are trivial:

        // csvfield: return ptr to the n-th field
        char *csvfield(int n)
        {
            if (n < 0 || n >= nfield)
                return NULL;
            return field[n];
        }

        // csvnfield: return number of fields
        int csvnfield(void)
        {
            return nfield;
        }

    Finally, we can modify the test driver to exercise this version of the library; since it keeps a copy of the input line, which the prototype does not, it can print the original line before printing the fields:

        //csvtest main: test CSV library
        int main(void)
        {
            int i;
            char *line;

            while ((line = csvgetline(stdin)) != NULL) {
                printf("line: '%s'\n", line);
                for (i = 0; i < csvnfield(); i++)
                    printf("field[%d] = '%s'\n", i, csvfield(i));
            }
            return 0;
        }
          
    This completes our C version. It handles arbitrarily large inputs and does something sensible even with perverse data. The price is that it is more than dour times as long as the first prototype and some of the code is intricate. Such expansion of size and complexity is a typical result of moving from prototype to production.

  Ex 4-1 There are several degrees of laziness for field splitting; amon the possibilities are to split all at once but only when some field is requested, to split only the field requested, or to split up to the field requested. Ennumerate possibilities, asses their potential dificulty and benefits, then write them and measure their speeds.

  Ex 4-2 Add a facility so separators can be changed (a) to an arbitraray class of chararcters; (b) to different separators for different fields; (c) to a regular expression (see Chapter 9). What should the interface look like?

  Ex 4-3 We chose to use the static initialization provided by C as the basis of a one-time switch: if a ptr is NULL on entry, initialization is performed. Another possibility is to require the user to call an explicit initialization function, which could include suggested initial sizes of arrays. Implement a version that combines the best of both. What is the role of reset in your implementation?

  Ex 4-4 Design and implement a library for creating CSV formatted data. The simplest version might take an array of strings and print them with quotes and commas. A more sophisticated version might use a format string analogous to printf. Look at Chapter 9 for some suggestions on notation.



*********************************************
4.4 A C++ Implementation
*********************************************

    In this section we will write a C++ version of the CSV library to address some of the remaining limitations of the C version. This will entail some changes to the specification, of which the most important is that the functions will handle C++ strings instead of C character arrays. The use of C++ strings will automatically resolve some of the storage management issues, since the library functions will manage the memory for us. In particular, the field routines will return strings that can be modified by the caller, a more flexible design than the previous version.

    A class Csv defines the public face, while neatly hiding the variables and functions of the implementation. Since a class object containes all the state for an instance, we can instantiate multiple Csv variables; each is independent of the others so multiple CSV input streams can operate at the same time.

        class Csv { // read and parse comma-separated values
            // sample input: "LU",86.25,"11/4/1998","2:19PM",+4.0625
            
            public:
              Csv(istream& fin = cin, string sep = ",") :
                  fin(fin), fieldsep(sep) {}

              int getline(string&);
              string getfield(int n);
              int getnfield() const { return nfield; }

            private:
              istream& fin;         // input file pointer
              string line;          // input line
              vector<string> field; // field strings
              int nfield;           // number of fields
              string fieldsep;      // separator characters

              int split();
              int endofline(char);
              int advplain(const string& line, string& fld, int);
              int advquoted(const string& line, string& fld, int);
        };

    Default parameters for the constructor are defined so a default Csv object will read from the standard input stream and use the normal field separator; either can be replaced with explicit values.

    To manage strings, the class uses the standard C++ string and vector classes rather than C-style strings. There is no non-existent state for a string: "empty" means only that the length is zero, and there is no equivalent NULL, so we cannot use that as an end of file signal. This Csv::getline returns the input line through an argument by reference, reserving the function value itself for end of file and error reports.

        // getline: get one line, grow as needed
        int Csv::getline(string& str)
        {
            char c;

            for (line = ""; fin.get(c) && !endofline(c); )
                line += c;
  
            split();
            str = line;
            return !fin.eof();
        }

    The += operator is overloaded to append a char to a str.

    Minor changes are needed in endofline. Again, we have to read the input a character at a time, since none of the stdin routiones can handle the variety of inputs.

        // endofline: check for and consume \r, \n, \r\n, or EOF
        int Csv::endofline(char c)
        {
            int eol;

            eol = (c=='\r' || c=='\n');
            if (c == '\r') {
                fin.get(c);
                if (!fin.eof() && c != '\n')
                    fin.putback(c); // read too far
            }
            return eol;
        }

    Here is the new version of split:

        // split: split line into fields
        int Csv::split()
        {
            string fld;
            int i, j;

            nfield = 0;
            if (line.length() == 0)
                return 0;
            i = 0;

            do {
                if (i < line.length() && line[i] == '"')
                    j = advquoted(line, fld, ++i);  // skip quote
                else
                    j = advplain(line, fld, i);
                if (nfield >= field.size())
                    field.push_back(fld);
                else
                    field[nfield] = fld;
                nfield++;
                i = j + 1;
            } while (j < line,length());
            return nfield;
        }

    Since strcspn does not wirk on C++ strings, we must change both split and advquoted. The new version of advquoted uses the C++ standard function s.find_first_of(fieldsep, j) searches the string s for the first instance of any char in fieldsep that occurs at or after position j; If it fails to find an instance, it returns an index beyond the end of the string, so we must bring it back within range. The innder for loop that follows appends chars up to the separator to the field being accumulated in fld;

        // advquoted: quoted field; return index of next separator
        int Csv::advquoted(const string& s, string& fld, int i)
        {
            int j;

            fld = "";
            for (j = i; j < s.length(); j++) {
                if (s[j] == '"' && s[++j] != '"') {
                    int k = s.find_first_of(fieldsep, j);
                    if (k > s.length()) // no separator found
                        k = s.length();
                    for (k -= j; k-- > 0; )
                        fld += s[j++];
                    break;
                }
                fld += s[j];
            }
            return j;
        }

    The function find_first_of is also used in a new fn called advplain, which advances over a plain unquoted field. Afain, this change is required because C string functions like strcspn cannot be applied to C++ strings, which are an entirely different data type.

        // advplain: unquoted field; return index of next separator
        int Csv::advplain(cnst string& s, string& fld, int i)
        {
            int j;
  
            j = s.find_first_of(fieldsep, i);   // look for separator
            if (j > s.length())
                j = s.length();
            fld = string(s, i, j-i);
            return j;
        }

    As before, Csv::getfield is trivial, while Csv:getnfield is so short that it is implemented in the class definition.

        // getfield: return n-th field
        string Csv::getfield(int n)
        {
            if (n < 0 || n >= nfield)
                return "";
            else
                return field[n];
        }

    Our test program is a simple variant of the earlier one:

        // Csvtest main: test Csv class
        int main(void)
        {
            string line;
            Csv csv;

            while (csv.getline(line) != 0) {
                cout << "line = '" << line << "'\n";
                for (int i = 0; i < csv.getnfield(); i++)
                    cout << "field[" << i << "] = '" << csv.getfield(i) << "'\n";
            }
            return 0;
        }

    The usage is different than with the C version, though only in a minor way. Depending on the compiler, the C++ version is anywhere from 40% to four times slower than the C version on a large input file of 30,000 lines with about 25 fields per line. As we saw when comparing versions of markov, this variability is a reflection on library maturity. The C++ source program is about 20% shorter.

  Ex 4-5 Enhance the C++ implementation to overload subscripting with operator[] so that fields can be accessed as csv[i].

  Ex 4-6 Write a Java version of the CSV library, then compare the three implementations for clarity, robustness, and speed.

  Ex 4-7 Repackage the C++ version of the CSV code as an STL iterator.

  Ex 4-8 The C++ version permits multiple independent Csv instances to operate concurrently without interfering, a benefit of encapsulating all the state in an object that can be instantiated multiple times. Modify the C version to achieve the same effect by replacing the global data structures with structures that are allocated and initialized by an explicit csvnew function.



*********************************************
4.5 Interface Principles
*********************************************

    In the previous sections we were working out the details of an interface, which is the detailed boundary between code that provides a service and code that uses it. An interface defines what some body of code does for its users, how the functions anf perhaps data members can be used by the restof the program. Our CSV interface provides three functions --read a line, get a field, and return the number of fields-- which are the only operations that can be performed.

    To prosper, and interface must be well suited for its task--simpl, general, regular, predictable, robust-- and it must adapt gracefully as its users and its implementation change. Good interfaces follow a set of principles. These are not independent or even consistend, but they helpd us describe what happens across the boundary between two pieces of software.

HIDE IMPLEMENTATION DETAILS:

    The implementation behind the interface shouldbe hidden from the rest of the program so it can be changed without affecting or breaking anything. There are several terms for this kind of organizing principle; information hiding, encapsulation, abstraction, modularization, and the like all refer to related ideas. An interface should hide details of the implementation that are irrelevant to teh client (user) of the interface. Details that are invisible can be changed without affecting the client, perhaps to extend the interface, make it more efficient, or even replace its implementation altogether.

    The basic libraris of most programming languages provide familiar examples, though not always especially well-designed ones, The C standard I/O library is among the best known: a couple of dozen functions that open, close, read, write, and otherwise manipulate files. The implementation of file I/O is hidden behind a data type FILE* whose properties one might be able to see (because they are often spelled our in <stdio.h>) but should not exploit.

    If the header file does not include the actual structure declaration, just the name of the structure, this is sometimes called an opaque type, since its properties are not visible and all operations take place through a pointer to whatever real object lurks behind.

    Avoid global variables; wherever possible it is better to pass references to all data through function arguments.

    We strongly recommend against publicly visible data in all forms; it is too hard to maintain consistency of values if users can change variables at will. Function interfaces make it easier to enforce access rules, but this principle is often violated. The predefined I/O streams like stdin and stdout are almost always defined as elements of a globall array of FILE structures:

        extern FILE     __iob[_NFILE];
        #define stdin   (&__iob[0];
        #define stdout  (&__iob[1]);
        #define stderr  (&__iob[2]);

    This makes the implementation completely visible; it also means that one cannot assign stdin stdout or stderr even though they look like variables. The peculiar name __iob uses the ANSI C convention of two leading underscores for private names that must be visible, which makes the names less likely to conflict with names in a program.

    Classes in C++ and Java are better mechanisms for hiding information; they are central to the proper use of those languages. The container clases of the C++ standard template library that we used in Chapter 3 carry this even further: aside from some performance guarantees there is no information about implementation, and library creators can use any mehcanism they like.

CHOOSE A SMALL ORTHOGONAL SET OF PRIMITIVES:

    An interface shuld provide as much functionality as necessary but no more, and the fucntions should not overlap excessively in their capabilities, Having lots of functions may make the library easier to use--whatever one needs is there for the taking. But a large interface is harder to write and maintain, the sheer size may make it hard to learn and use as well. "Application program interfaes" or APIs are sometimes so huge that no mortal can be expected to master them.

    In the interest of convenience, some interfaces provide multiple ways of doing the same thing, a tendency that should be resisted. The C standard I/O library provides at least four differnet fucntions that will write a singe char to an outpur stream:
        
        char c;
        putc(c, fp);
        fputc(c, fp);
        fprintf(fp, "%c", c);
        fwrite(&c, sizeof(char), 1, fp);

    If the steadm is stdout, there are several more possibilities, These are convenient, but not all are necessary.

    Narrow interfaces are to be preferred to wide ones, at least until one has strong evidence that more functions are needed. Do one thing, and do it well, Do not add to an interface just because it is possible to do so, and do not fix the interface when it is the implementation that is broken. For instance, rather than having memcpy for speed and memmove for safety, it would be better to have one function that was always safe, and fast when it could be.


DON'T REACH BEHIND THE USER'S BACK:

    A library function should not write secret files and variables or change global data, and it should be circumspect about modifying data in its caller. The strtok function fails several of these criteria. It is a bit of a surprise that strtok writes null bytes into the middle of its input string. Its use of the null pointer as a signal to pick up where it left off last time implies secret data held between calls, a likely source of bugs, and it precludes concurrent uses of the function. A better design would provide a single function that tokenizes and inpur string, For similar reasons, our second C version cannot be used for 2 input streams; see ex 4-8
  
    The use of one interface shuld not demand another one just for the convenience of the interface designer or implementer. INstead, make the interface self contained, or failing that, be explicit about what external services are required. Otherwise, you place a maintenance burden on the clent, An obvious example is the pain of managing huge lists of header files in C and C++ source;header files can be thousands of lines long and include dozens of other headers.

DO THE SAME THING THE SAME WAY EVERYWHERE:

    Consistency and regularity are important. Related things should be achieved by related means, The basic str... functions in the C library are easy to use without documentation because they all behave about the same: data flows from right to left, the same direction as in an assignment statement, and they all return the resulting string. On the other hand, int he C standard I/O library it is hard to predict the order of arguments to functions, Some have FILE* argument first, some last; others have various orders for size and number of elements. The algorithms for STL containers present a very uniform interface, so it is easy to predict how to use an unfamiliar function.

    External consistenct, hevaing like something else, is also a goal. For example, the mem... functions were designed after the str... functions in C, but borrowed their style. The standard I/O functions fread and fwrite would be easier to remember if they looked like the read and write functions they were based on. Unix command-line options introduced by a minus sign, but a given option letter may mean completely different things, even between related programs.

    If wildcards liek the * in *.exe are all expanded by a command interpreter, behavior is uniform. If they are expanded by individual programs, non uniform behavior is likely. Web browsers take a single mouse click to follow a link, but other applications take two clicks to start a program or follow a link; the result is that many people automatically click twice regardless.

    These principles are easier to follow in some environments than others, but they still stand. For instance it is hard to hide implementation details in C, but a good programmer will not exploit them, because to do so makes the details part of th einterface and violates the principle of information hiding. Comments in header files, names with special forms (such as __iob), and so on are ways of encouraging good behavior when it cannot be enforced.

    No matter what, there is a limit to how well we can do in designing an interface. Even the best interfaces of today may eventually become problems of tomorrow, but good design can push tomorrow off a while longer.



*********************************************
4.6 Resource Management
*********************************************

    One of the most difficult problems in designing the interface for alibrary (or a class or a package) is to manage resources that are owned by the library or that are shared by the library and those who call it. The most obvious such resource is memory--who is responsible for allocating and freeing storage?--but other shared resources include open files and the state of variables whose values are of common interest. Roughly, the issues fall into the categories of initialization, maintaining state, sharing and copying, and cleaning up.

    The prototype of our CSV package used static initialization to set th einitial values for pointers, counts, and the like, But this choice is limiting since it prevents restarting the routines in their initial state once one of the functions has been called. An alternative is to provide an initialization function that sets all internal values to the correct initial values. This permits restarting, but relies on the user to call it explicitly, The reset function in the second versions could be made public for this purpose.

    In C++ and Java, constructors are used to initialize data members of classes, Properly defined constructors ensure that all data members are initialized and that there is no way to create an uninitilaized class object. A group of constructors can support various kinds of initializers; we might provide Csv with one constructor that takes a file name and another that takes an input stream,

    What about copies of information managed by a library, suhc as the inout lines and fields? Our C csvgetline program provides direct access to the input strings (line and fields) by returning pointers to them. This unrestricted access has several drawbacks. It is possible for the user to overwrite memory so as to render other information invalid; for example, an expression like:

        strcpy(csvfield(1), csvfield(2));

could fail ina  variety of ways, most likely by overwriting the beginning of field 2 if field 2 is longer than field 1. The user of the library must make a copy of any information to be preserved beyond the next call to csvgetline; in the following sequence, the pointer mught well be invalid at the end if the second csvgetline causes a reallocation of its line buffer:

        char *p;
    
        csvgetline(fin);
        p = csvfield(1);
        csvgetline(find);
        // p could be invalid here

    The C++ version is safer because the strings are copies that can be changed at will. 

    Java uses references to refer to objects, that is, any entity other than one of the basic types like int. This is more efficient than making a copy, but one can be fooled into thinking that a reference is a copy; we had a bug like that in an early version of our Java markov program and this issue is a prennial source of bugs involving strings in C. Clone methods provide a way to make a copy when necessary.

    The other side of initialization or construction is finalization or destruction--cleaning up and recovering resources when some entity is no longer needed. This is particularly important for memory, since a program that fails to recover unsued memory will eventually run out. Much modern software is embarrasingly prone to this fault. Related problems occur when open files are to be cloes: if data is being buffered, the buffer may have to be flushed (and its memory reclaimed). For standard C library functions, flushing happens automatically when the program terminates normally, but it must otherwise be programmed. The C and C++ std function atexit provides a way to get control just before a program terminates normally; interface implementers can use this facility to schedule a cleanup.

FREE A RESOURCE IN THE SAME LAYER THAT ALLOCATED IT:

    One way to control resource allocation and reclamation is to have the same library, package, or interface that allocates a resource be responsbile for freeing it. Another way of saying this is that the allocation state of a resource shoulf not change accross the interface. Our CSV libraries read data from files that have alreadt been opened, so they leave them open when they are done. The caller of the library needs to close files.

    C++ constructors and destructors help enforce this rule. When a class instance goes out of scope or is explicitly destroyed, the destructor is called; it can flush buffers, recover memory, reset values, and do whatever else is necessary. Java does not provude an equivalent mechanism. Although it is possible to define a finalization method for a class, there is no assurance that it will run at all, let alone at a particular time, so cleanup actions cannot be guaranteed to occur, although it is often reasonable to assume they will.

    Java does provide considerable help with memory management because it has built-in garbage collection. As a program runs, it allocates new objects. There is no way to deallocate them explicitly, but the run-time system keeps track of which objects are still in use and which are not, and periodically returns unused ones to the available memory pool.

    There are a variety of techniques for garbage collection. Some schemes keep track of the number of uses of each obejcts, its reference count, and free and object when its reference count goes to zero. Other algs periodically follow a trail from the allocation pool to all referenced objects. Objects that are found this way are still in use; objects that are not referred to by any othre object are not in use and can be reclaimed.

    The existence of automatic garbage-collection does not mean that there are no memory-management ssues ina  design. We still have to determine whether interfaces return references to shared objects or copies of them, and this affects the entire porogram. Nor is garbage-collection free--there is overhead to maintain information and to reclaim unused memory, and collection may happen at unpredictable times,

    All of these problems become more complicated if a library is to be used in an environment where more than one thread of control can be executing its routines at the same time, as in a multi-threaded Java program.

    To avoid problems, it is necessary to write code that is reentrant, whicb means that it works regardless of the number of simultaneous executions. Reentrant code will avoid global variables, static local variables, and any other variable that could be modified while another thread is using it, The key to good multi-thread design is to separarate the components so they share nothung exvept through well defined interfaces. Libraries that inadvertently expose variables to sharing destroy the model. (In a multi-thread program, strtok is a disaster, as are other functions in the C library that store values in internal static memory.) If variables might be shared, they must be protected by some kind of locking mechanism to ensure that only one thread at a time accesses them. Classes are a big help here because they provide focus for discussing sharing and locking models. Synchronized methods in Java provide a way for one thread to lock and entire class or instance of a class against simultaneuous modification by some other thread; synchronized blocks permt only one thread at a time to execute a section of code.

    Multi threadding adds a significant complexity to programming issues, and it is too big a topic for us to discuss in detail here.


*********************************************
4.7 Abort, Retry, Fail?
*********************************************

    
