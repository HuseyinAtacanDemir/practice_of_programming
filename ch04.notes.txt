*********************************************
*********************************************
Chapter 04: Interfaces
*********************************************
*********************************************

  "Before I built a wall I'd ask to know        \
  What I was walling in or walling out,         \
  And to whom I was like to give offence.       \
  Something there is that doesn't love a wall,  \
  That wants it down."
                    Robert Frost, Mending Wall

  The essence of design sis to balance competing goals and constraints. Although there may be many tradeoffs, when one is writing a small self-contained system, the ramifications of particular choices remain within the system and affect only the individual programmer. But when code is to be used by others, decisions have far wider repercussins.

  Among the issues to be worked out in a design are:

  • Interfaces: what services and access are provided? The interface is in effect a contract between supplier and customer. The desire to provide services that are uniform and convenient, with enough functionality to be easy to use but not so much as to become unwieldy

  • Information hiding: what information is visible and what is private? An interface must provide straightforward access to the components while hiding details of the implementation so they can be changed without affecting users.

  • Resource Management: who is responsible for managing memory and other limited resources? Here, the main problems are allocating and freeing storage, and managing shared copies of information.

  • Error handling: who detects errors, who reports them, and how? When an error is detected, what recovery is attempted?

  In Chapter 2 we looked at the individual pieces --the data structures-- from which a system is built. In Chapter 3, we looked at how to combine those into a small program. The topic now turns to the interfaces between components that might come from different sources. In this chapter we illustrate interface design by building a library of functions and data structurs for a common task. Along the way, we will present some principles of design. typically there are an enormous number of decisions to be made, but most are made almost unconsciously. Without these principles, the result is often the sort of haphazard interfaces that frustrate and impede programmers every day.


*********************************************
4.1 COMMA SEPARATED VALUES
*********************************************

    Comma separated values, or CSV, is the term for a natural and widely used representation for tabular data. Each row of a table is a line of text; the fields on each line are sepparated by commas. The table at the end of the previous chapter might begin this way in CSV format:

        ,"250MHz","400MHz","Lines of" 
        ,"R10000","Pentium II","source code"
        C,0.36 sec,0.30 sec,150 
        Java,4.9,9.2,105
    
    This format is read and written by programs such as spreadsheets; not coincidentally, it also appears on web pages for services such as stock price quotations. A popular web page for stock quotes presents a display like this:
        ------------------------------------------------------------------
        | Symbol  |      Last Trade     |      Change       |   Volume   |
        ------------------------------------------------------------------
        | LU      |  2:19PM  |  86-1/4  | +4-1/16 | +4.94%  |  5,804,800 |    
        ------------------------------------------------------------------
        | T       |  2:19PM  | 60-11/16 | -1-3/16 | -1.92%  |  2,468,000 |    
        ------------------------------------------------------------------
        | MSFT    |  2:24PM  | 106-9/16 |  +1-3/8 | +1.31%  | 11,474,900 |
        ------------------------------------------------------------------

                          Download Spreadsheet Format
                          ---------------------------

    Retrieving numbers by interacting with a web browser is effective but time consuming. It's a nuissance to invoke a web browser, wait, watch a barrage of ads, type a list of stocks, wait, wait, wait, then watch another barrage, all to get a few numbers. To process the numbers further requires even more interaction; selecting the "Download Spreadsheet Format" link retrieves a file that contains much the same information in lines of CSV data like these :

        "LU",86.25,"11/4/1998","2:19PM",+4.0625, 83.9375,86.875,83.625,5804800
        "T",60.6875,"11/4/1998","2:19PM",-1.1875, 62.375,62.625,60.4375,2468000
        "MSFT",106.5625,"11/4/1998","2:24PM",+1.375, 105.8125,107.3125,105.5625,11474900

    Conspicuous by its abscence in this process is the principle of letting the machine do the work. Browsers let your computer access data on a remote server, but it would be more convenient to retrieve the data without forced interaction. Underneath all the button pushing is a purely textual procedure --the browser reads some html, you type some text, the browser sends that to a server and reads some HTML back. With the right tools and language, it is easy to retrieve the info automatically. Here's a program in the language Tcl to access the stock quote web site and retrieve CSV data in the format above, preceded by a few header lines:

        # getquotes.tcl: stock prices for Lucent, AT&T, Microsoft
        set so [socket quote.yahoo.com 80]  ;#connect to server
        set q "/d/quites.csv?s=LU+T+MSFT&f=sl1d1t1ohgv"

        puts $so "GET $q HTTP/1.0\r\n\r\n"  ;# send requrest
        flush $so 
        puts [read $so]                     ;# read & print reply

    The cryptic sequence f=... that follows the ticker symbols in an undocumented control string, analogous to the first argument of printf, that determines what values to retrieve. By experiment, we determined that s identifies the stock symbol, l1 the last price, c1 the change since yesterday, and so on. What's important is not the details, which are subject to change anyway, but the possibility of automation: retrieving the desired information and converting it into the form we need without any human intervention. We can let the machine do the work.

    It typically takes a fraction of a second to run getquotes, far less interacting with a browser. ONce we have the data, we will want to process it further. Data formats like CSV work best if there are convenient libraries for converting to and from the format, perhaps allied with some auxiliary processing such as numerical conversions. But we do not know of an existing public library to handle CSV, so we will write one ourselves.

    In the next few sections, we will build three versions of a library to read CSV data and converti it into an internal representation. Along the way, we'll talk about issues that arise when designing software that must work with other software. For example, there does not appear to be a standard definition of CSV, so the implementation cannot be based on a precise specification, a common situation in the design of interfaces.


*********************************************
4.2 A PROTOTYPE LIBRARY 
*********************************************

    We are unlikely to get the design of a library or interface right on the first attempt. As Fred Brooks once wrote, "plan to throw away; you will, anyhow." Brooks was writing about large systems but the idea is relevant for any substantial piece of software. It is not usually until you have built and used a version of the program that you understand the issues well enough to get the design right.

    In this spirit, we will approach the construction of a library for CSV by building one to throw away, a prototype. Our first version will ignore many of the difficulties of a thoroughly engineered library, but will be complete anough to be useful and to let us gain some familiarity with the problem.

    Our starting point is a function csvgetline that reads one line of CSV data from a file into a buffer, splits it into fields in an array, removes the quotes, and returns the number of fields, Over the years, we have written similar code in almost every language we know, so it is a familiar task. Here is a prototype version in C; we have marked it as questionable because it is just a prototype:

?       char buf[200];        // input line buffer
?       char *fled[20];       // fields
?
?       // csvgetline: read and parse line, return field count
?       // sample input: "LU",82.25,"11/4/1998","2:19PM",+4.0625
?       int csvgetline(FILE *fin)
?       {
?           int nfield;
?           char *p, *q;
?
?           if (fgets(buf, sizeof(buf), fin) == NULL)
?               return -1;
?           nfield = 0;
?           for (q = buf; (p=strtok(q, ",\n\r")) != NULL; q = NULL)
?               field[nfield++] = unquote(p);
?           return nfield;
?       }

    The comment at the top of the function includes an example of the input format that the program accepts; such comments are helpful for programs that parse messy input.

    The CSV format is too complicated to be parsed easily by scanf so we use the C standard library function strtok. Each call of strtok(p, s) returns a pointer to the first token within p consisting of characters not in s; strtok terminates the token by overwriting the following character of the original string with a null byte. On the first call, strtok's first argument is the string to scan; subsequent calls use NULL to indicate that scanning should resume where it left off in the previous call. This is a poor interface. Because strtok stores a variable in a secret place between calls, only one sequence of calls may be active at one time; unrelated interleaved calls will interfere with each other.

    Our fn unquote removes the leading and trailing quotes that appear in the sample input above. It does not handle nested quotes, however, so although sufficient for a prototype, it is not general.

?       // unquote: remove leading and trailing quote
?       char *unquote(char *p)
?       {
?           if (p[0] == '"') {
?               if (p[strlen(p) - 1] == '"')
?                   p[strlen(p)-1] = '\0';
?               p++;
?           }
?           return p;
?       }

    A simple test program helps verify that csvgetline works:

?       // csvtest main: test csvgetline function
?       int main(void)
?       {
?           int i, nf;
?
?           while ((nf = csvgetline(stdin)) != -1)
?               for (i = 0; i < nf; i++)
?                   printf("field[%d] = '%s'\n", i, field[i]);
?           return 0;
?       }

    The printf encloses the fields in matching single quotes, which demarcate them and help revelat bugs that handle white space incorrectly.
  
    We can now run this on the output produced by getquotes.tcl

        sh> tclsh getquotes.tcl | csvtest

    Now we have a prototype that seems to work on data of the sort we showed above. But it might be prudent to try it on something else as well, especially if we plan to let others use it. We found another website that downloads stock quotes and obtained a file of similar information but in a different form: carriage return (\r) rather than newlines to separate records, and no terminating carriage return at the end of the file.

    With that kind of input, our prototype failed miserably.

    We designed our prototype after examining one data source, and we tested it orogonally only on data from that same source. Thus we shouldn't be surprised when the first encounter with a different source reveals gross failings. Long input lines, many fields, and unexpected or missing separators all cause trouble. This fragile prototype might serve for personal use or to demonstraate the feasibility of an approach, but no more than that. It's time to rethink the design before we try another implementation.

    We made large number of decisions, both implicit and explicit, in the prototype. Here are some of the choices that were made, not always in the best way for a general-purpose library. Each raises an issue that needs more careful attention.
  
  • The prototype doesn't handle long input lines or lots of fields. It can give wrong answers or crash because it doesn't even check for overflows, let alone return sensible values in case of errors.
  
  • The input is assumed to consist of lines terminated by newlines.
 
  • Fields are separated by commas and surrounding quotes are removed. There is no provision for embedded quotes or commas.

  • The input line is not preserved; it is overwritten by the process of creating fields.

  • No data is saved from one input line to the next; if something is to be remembered, a copy must be made.

  • Access to fields is through a global variable, the field array, which is shared by csvgetline and functions that call it; there is no control over access to the field contents or the pointers. There is also no attempt to prevent access beyond the last field.

  • The global variables make the design unsuitable for multi-threaded environments or even two sequences of interleaved calls.

  • The caller must open and close files explicitly; csvgetline reads only from open files.

  • Input and splitting are inextricably linked: each call reads a line and splits it into fields, regardless of whether the application needs that service.

  • The return value is the number of fields on the line; each line must be split to compute this value. There is also no way to distinguish errors from end of file.

  • There is no way to change any of these properties without changing the code.

    This long yet incomplete list illustrates some of the possible design tradeoffs. Each decision is woven through the code. That is fine for a quick job, lije parsing one fixed format from a known source. But what id the format changes, or a comma appears within a quoted string, or the server produces a long line or a lot of fields?

    It may seem easy to cope, since the "library" is small and only a prototype anyway. Imagine, however, that after sitting on the shelf for a few months or years the code becomes part of a larger program whose specification changes over time. How will csvgetline adapt? If that program is used by others, the quick choices made in the original design may spell trouble that surfaces years later. This scenario is representative of the history of many bad interfaces. It is a sad fact that a lot of quick and dirty code ends up un widely-used software, where it remains dirty and often not as quick as it should have been anyway.



*********************************************
4.3 A LIBRARY FOR OTHERS 
*********************************************

  Using what we learned from the prototype, we now want to build a library worthy of general use. The mos obvious requirement is that we must make csvgetline mor robust so it will handle long lines or many fields; it must also be more careful in the parsing of fields.

    To create an interface that others can use, we must consider the issues listed at the beginning of this chapter: interfaces, information hiding, resource management, and error handling. The interplay among these strongly affects the design. Our separation of these issues is a bit arbitrary, since they are interrelated.

INTERFACE: We decided on three basic opeartions:
        char  *csvgetline (FILE *)  : read a new CSV line
        char  *csvfield   (int n)   : return the n-th field of the current line
        int   csvnfield   (void)    : return the number of fields in the curent line

  What function value should csvgetline return? It is desiarble to return as much useful information as convenient, which suggests returning the number of fields, as in the prototype. But then the number of fields must be computed even if the fields are not being used. Another possible value is the input line length, which is affected by whether the trailing newline is preserved. After several experiments, we decided that csvgetline will return a pointer to the original line of input, or NULL if end of file has been reached.

  We will remove the newline at the end of the line returned by csvgetline, since it can easily be restored if necessary.

  The definition of a field is complicated; we have tried to match what we observe empirically in spreadsheets and other programs. A field is a sequence of zero or more characters. Fields are separated by commas. Leading and trailing blanks are preserved. A field may be enclosed in double-quote characters, in which case it may contain commas. A quoted field may contain double quote characters, which are represented by a double double quote; the CSV field "x""y" defines the string x"y. Fields my be empty; a fields specified as "" is empty, and identical to one specified by adjacent commas.

  Fields are numbered from zero. What if user asks for a non existent field by calling csvfield(-1) or csvfield(1000000)? We could return "" (empty string) because this can be printed and compared; programs that process variable numbers of fields would not have to take special precautions to deal with non existent ones. But that choice provides no way to distinguish empty from non existent. A second choice would be to print an error message or even abort; we will discuss shortly why this is not desirable. We decided to return NULL, the convenient value for a non existent string in C.


INFORMATION HIDING:

    The library will impose no limits on input line lenght or number of fields. To achieve this, either the caller must provide the memory or callee (the library) must allocate it. The caller of the library function fgets passes in an array and a maximum size. If line is longer than the buffer, it is broken into pieces. This behavior is unsatisfactory for the CSV interface, so our library will allocate memory as it discovers that more is needed.

    Thus only csvgetline knows about memory management; nothing about the way that it organizes memory is accessible from outside. The best way to provide that isolation is thrugh a function interface: csvgetline reads the next line, no matter how big, csvgfield(n) returns a pointer to thebytes of the n-th field of the current line, and csvnfield returns the number of fields on the current line.

    We will have to grow memory as longer lines or more fields arrive. Details of how that is done are hidden in the csv functions; no other part of the program knows how this works, for instance whether the library uses small arrays that grow, or very large arrays, or something completetly different. nor does the interface reveal when memory is freed.

    If user calls only csvgetline, there is no need to split into fields; lines can be split on demand. Whether field splitting is eager (done right away when the line is read) or lazy (done only when a field or count is needed) or very lazy (only the requested field is split) is another implementation detail hidden from the user.


RESOURCE MANAGEMENT:

    We must decide who is responsible for shared information. Does csvgetline return the original data or make a copy? We decided that the return value of csvgetline is a ptr to the org input, which will be overwritten when the next line is read. Fields will be built in a copy of the input line, and csvfield will return a ptr to the field within the copy. With this arrangement, the suer must make another copy if a particular line or field is to be saved or changed, and it is the users responsibility to release that storage when it is no longer needed. 

    Who opens and closes the input file? Whoever ppens an input file should do the corresponding close; matching tasts should be done at the same level or place. WE will assume that csvgetline is called with a FILE pounter to an already open file that the caller will close when processing is complete.

    Managing the resources shared or passed across the boundary between a library and its callers is a diffigult task, and there are often sound but cinflcting reasons to prefere various design choices. Errors and misunderstandings about the shared responsibilities are a frequent source of bugs. 

ERROR HANDLING

    Because csvgetline returns NULL, ther eis no good way to distinguish end of file from an error like running out of mem; similaryl, access to a non existent field causes no error. By analogy with ferror, we could add another fnction csvgeterror to the interface to report the most recent error, but for simplicity we will leave it out of this version.

    As a principle, library routines shoud not just die when an error occurs; error status wdhould be returned to the caller for approproate acion. Nor should they print messages or pop up dialog boxes, since they may be running in an env where a messag would interfere with something else. Error handling is a topic worth a sparate discussion of its own, later in this chapter.

SPECIFICATION

    The choices made above should be collected in one place as a specification of the serviecs that csvgetline provides and how it is to be used, In a large project, the specification prcedes the implementation, because psecifiers and implementers are usually different people and may be in different organizations. In practice, however, work often proceeds in parallel, with specification an docde evolving together, although sometimes the "specification" is written only after the fact to describe approx what the code does.

    The best approach is to write the specification early and revise it as we learn from the ongoing pimlementation. The more accurate and careful a specifiation is, the more likely that the resulting program will work well. Even for personal progras, it is valuable to prepare a reasonably thorough specification because it encourages consideration of alternatives and records the choices made. 

    For our purposes, the specification would include fn prototypes and a detailed prescription of beheavior, responsibilities and assumptions:



        Fields are separarted by commas.
        A field may be enclosed in db quote chars "..."
        A quoted field may contain commas but not newlines
        A quoted field may containe db quote chars ", represented by ""
        Fields may be empty; "" and an empty string both represents an empty field.
        Leading and trailing white space is preserved

        char *csvgetline(FILE *f);
            reads one line from open input file f;
                assumes taht input lines are terminated by \r, \n, \r\n, or EOF
            returns ptr to line, with terminator removed, or NULL if EOF occurred.
            line may be of arbitrary len; returns NULL of mem limit exceeded.
            line must be treated as read only storage;
                caller must make a copy to preserve or change contents

        char *csvfield(int n);
            fields are numbered from 0
            returns n-th field from the last line read by csvgetline
                returns NULL if n<0 or beyond last field
            fields are separated by commas
            fields may be surrounded by "..." such quotes are removed
                within ".." "" replaced by " and comma is not a separator
            in unquoted fields, quotes are regular chars
            there can be an arbitrary num of fields of any len
                returns NULL if mem lim exceeded
            field must be treated as read-only storage
                caller must make a copy to preserve or change contents
            behavior undefined if called before csvgetline is called

        int csvnfield(void);
            returns number of fields on last line read by csvgetline
            behavior undefined if called before csvgetline is called



    This spec still elaves open questions. For examlpe, what values should be returned by csvfield and csvnfield if they are called after csvgetline has encountered EOF? How should ill formed fields be handled? Nailing down all such puzzles is difficult even for a tiny system, and very challendging for a large one, though it is important to try. One often doesnt discover oversights and omissions until implementation is underway.

    The rest of this section contains a new implmentation of csvgetline that matches the spec. The lib is broken into two files, a header csv.h that containes the fn declarations that represent the public part of the interface, and an impleentation file csv.c that contains the code. Users include csv.h in their source code and link their completed code with the compiled version of csv.c; the source need never be visible.

    Here is the header file:

        // csv.h: interface for csv library
        extern char *csvgetline(FILE *f);   // read next input line
        extern char *csvfield(int n);       // return field n
        extern int  csvnfield(void);        // return number of fields

    The internal variables that store text and the internal fns like split are declared static so they are visible only within the file that containes them. This is the simples way to hide information in a C program.



        enum { NOMEM = -2 };          // out of mem signal

        static char *line   = NULL;   // input chars
        static char *sline  = NULL;   // line copy used by split
        static int maxline  = 0;      // size of line[]and sline[]
        static char **field = NULL;   // field ptrs
        static int maxfield = 0;      // size of field[]
        static int nfield   = 0;      // number of fields in field[]

        static char fieldsep[] = ","; // field separator chars



    The vars are initialized statically as well. These initial values are used to test whether to create or grow arrays.

    These declarations describe a simple data structure. The line array holds the input line; the sline array is created by copying chars from line and terminating each field. The field array points to entries in sline. This diagram shows the state of these three arrays after the input line ab, "cd", "e""f",,"g,h" has been processed. Underlined elements in sline are not part of any field:


            ----------------------------------------------------------------
    line    | a| b| ,| "| c| d| "| ,| "| e| "| "| f| "| ,| ,| "| g| ,| h| "|   

            ----------------------------------------------------------------
    sline   | a| b|\0| "| c| d|\0|\0| "| e| "| f|\0| "|\0|\0| "| g| ,| h|\0|
              ^       --  ^       -----  ^          -----  ^ --- ^
              0           1              2                 3     4


    Here is the fn csvgetline itself:

        // csvgetline: get one line, grow as needed
        // sample input: "LU",86.25,"11/4/1998","2:19PM",+4.0625
        char *csvgetline(FILE *fin)
        {
            int i, c;
            char *newl, *news;

            if (line == NULL) {           // allocate on first call
                maxline = maxfield = 1;
                line = (char *) malloc(maxline);
                sline = (char *) malloc(maxline);
                field = (char **) malloc(maxfield*sizeof(field[0]));
                if (line == NULL || sline == NULL || field == NULL) {
                    reset();
                    return NULL;
                }
            }
            for (i=0; (c=getc(fin))!=EOF && !endofline(fin,c); i++) {
                if (i >= maxline-1) {     // grow line
                    maxline *= 2;         // double current size
                    newl = (char *) realloc(line, maxline);
                    news = (char *) realloc(sline, maxline);
                    if (newl == NULL || news == NULL) {
                        reset();
                        return NULL;
                    }
                    line = newl;
                    sline = news;
                }
                line[i] = c;
            }
            line[i] = '\0';
            if (split() == NOMEM) {
                reset();
                return NULL;
            }
            return (c == EOF && i == 0) ? NULL : line;
        }

    An incoming line is accumulated in line, which is grown as necessary by a call to realloc; the size is doubled on each growth, as in Section 2.6. The sline array is kept the same size as line; csvgetline calls split to create the field pointers in a separate array called field, which is also grown as needed.

    As is our custom, we start the arrays very small and grow them on demand, to guarantee that the array growing code is exercised. If allocation fails, we call reset to restore the globals to their starting state, so a subsequent call to csvgetline has a chance of suceeding:

        // reset: set variables back to starting values
        static void reset(void)
        {
            free(line);
            free(sline);
            free(field);
            line = NULL;
            sline = NULL;
            field = NULL;
            maxline = maxfield = nfield = 0;
        }

    The endofline function handles the problem that an input line may be terminated by a carraige return, a newline, both, or even EOF:

        // endofline: check for and consume \r, \n, \r\n, or EOF
        static int endofline(FILE *fin, int c)
        {
            int eol;

            eol = (c=='\r' || c=='\n');
            if (c == '\r') {
                c = getc(fin);
                if (c != '\n' && c != EOF)
                    ungetc(c, fin); // read too far, put c back
            }
            return eol;
        }

    A separate function is necessary, since the stdin functions do not hand the rich variety of perverse formats encountered in real inputs.

    Our prototype used strtok to find the next token by searching for a separator character, normally a comma, but this made it impossible to handle quoted commas. A major change in the implementation of split is necessary, though its interface need not change. Consider these input lines:

        "",,""
        ,"",
        ,,

    Each line has three empty fields. Making sure that split parses them and other odd inputs correctly complicates it significantly, an example of how special cases and boundary conditions can come to dominate a program.

        // split: split line into fields
        static int split(void)
        {
            char *p, **newf;
            char **sepp;      // ptr to temp separator char
            int sepc;         // temp spearator char

            nfield = 0;
            if (line[0] == '\0')
                return 0;
            strcpy(sline, line);
            p = sline;

            do {
                if (nfield >= maxfield) {
                    maxfield *= 2;          // double current size
                    newf = (char **) realloc(field,
                                maxfield * sizeof(field[0]));
                    if (newf == NULL)
                        return NOMEM;
                    field = newf;
                }
                if (*p == '"')
                    sepp = advquoted(++p);    // skip initial quote
                else
                    sepp = p + strcspn(p, fieldsep);
                sepc = sepp[0];
                sepp[0] = '\0';               // terminate field
                field[nfield++] = p;
                p = sepp + 1;
            } while (sepc == ',');
            
            return nfield;
        }

    The loop grows the array of field ptrs if necessary, then calls one of two otehr fns to locate and process the enxt field. If the field begins with a quote, advquoted finds the field and returns a ptr to the separator that ends the field. Otherwise, to find the next comma we use the library fn strcspn(p, s), which searches a string p for the enxt occurrence of any char in string s; it returns the number of chars skipped over.

    Quotes within a field are represented by two adjacent quotes, so advquoted squeezes those into a single one; it also removes the quotes that surround the field. Some complexity is added by an attempt to cope with plausible inputs that dont match the spec, such as "abc"def. In such cases, we append whatever follows the second quote until the next separator as part of this field. Microsoft Excel appears to use a similar alg.

        // advquoted: quoted field; return ptr to next separator
        static char *advquoted(char *p)
        {
            int i, j;

            for (i = j = 0; p[j] != '\0'; i++, j++) {
                if (p[j] == '"' && p[++j] != '"') {
                    // copy up to next separator or \0
                    int k = strcspn(p+j, fieldsep);
                    memmove(p+i, p+j, k);
                    i += k;
                    j += k;
                    break; 
                }
                p[i] = p[j];
            }
            p[i] = '\0';
            return p + j;
        }

    Since the input line is already split, csvfield and csvnfield are trivial:

        // csvfield: return ptr to the n-th field
        char *csvfield(int n)
        {
            if (n < 0 || n >= nfield)
                return NULL;
            return field[n];
        }

        // csvnfield: return number of fields
        int csvnfield(void)
        {
            return nfield;
        }

    Finally, we can modify the test driver to exercise this version of the library; since it keeps a copy of the input line, which the prototype does not, it can print the original line before printing the fields:

        //csvtest main: test CSV library
        int main(void)
        {
            int i;
            char *line;

            while ((line = csvgetline(stdin)) != NULL) {
                printf("line: '%s'\n", line);
                for (i = 0; i < csvnfield(); i++)
                    printf("field[%d] = '%s'\n", i, csvfield(i));
            }
            return 0;
        }
          
    This completes our C version. It handles arbitrarily large inputs and does something sensible even with perverse data. The price is that it is more than dour times as long as the first prototype and some of the code is intricate. Such expansion of size and complexity is a typical result of moving from prototype to production.

  Ex 4-1 There are several degrees of laziness for field splitting; amon the possibilities are to split all at once but only when some field is requested, to split only the field requested, or to split up to the field requested. Ennumerate possibilities, asses their potential dificulty and benefits, then write them and measure their speeds.

  Ex 4-2 Add a facility so separators can be changed (a) to an arbitraray class of chararcters; (b) to different separators for different fields; (c) to a regular expression (see Chapter 9). What should the interface look like?

  Ex 4-3 We chose to use the static initialization provided by C as the basis of a one-time switch: if a ptr is NULL on entry, initialization is performed. Another possibility is to require the user to call an explicit initialization function, which could include suggested initial sizes of arrays. Implement a version that combines the best of both. What is the role of reset in your implementation?

  Ex 4-4 Design and implement a library for creating CSV formatted data. The simplest version might take an array of strings and print them with quotes and commas. A more sophisticated version might use a format string analogous to printf. Look at Chapter 9 for some suggestions on notation.



*********************************************
4.4 A C++ Implementation
*********************************************


